#include "Yang.h"

using namespace std;

const char* type2yk(E_YK_TYPE type)
{
	const static char* yklist[] = {
	"anyxml",
	"argument",
	"augment",
	"base",
	"belongs-to",
	"bit",
	"case",
	"choice",
	"config",
	"contact",
	"container",
	"default",
	"description",
	"enum",
	"error-app-tag",
	"error-message",
	"extension",
	"deviation",
	"deviate",
	"feature",
	"fraction-digits",
	"grouping",
	"identity",
	"if-feature",
	"import",
	"include",
	"input",
	"key",
	"leaf",
	"leaf-list",
	"length",
	"list",
	"mandatory",
	"max-elements",
	"min-elements",
	"module",
	"must",
	"namespace",
	"notification",
	"ordered-by",
	"organization",
	"output",
	"path",
	"pattern",
	"position",
	"prefix",
	"presence",
	"range",
	"reference",
	"refine",
	"require-instance",
	"revision",
	"revision-date",
	"rpc",
	"status",
	"submodule",
	"type",
	"typedef",
	"unique",
	"units",
	"uses",
	"value",
	"when",
	"yang-version",
	"yin-element",
	"add",
	"current",
	"delete",
	"deprecated",
	"false",
	"max",
	"min",
	"not-supported",
	"obsolete",
	"replace",
	"system",
	"true",
	"unbounded",
	"user",
	"action",
	"comment",
	"unknown",
	};
	return yklist[type];
}

E_YK_TYPE yk2type(const string& yk)
{
	static map<string, E_YK_TYPE> ykmap = {
	{"anyxml", YK_ANYXML},
	{"argument", YK_ARGUMENT},
	{"augment", YK_AUGMENT},
	{"base", YK_BASE},
	{"belongs-to", YK_BELONGS_TO},
	{"bit", YK_BIT},
	{"case", YK_CASE},
	{"choice", YK_CHOICE},
	{"config", YK_CONFIG},
	{"contact", YK_CONTACT},
	{"container", YK_CONTAINER},
	{"default", YK_DEFAULT},
	{"description", YK_DESCRIPTION},
	{"enum", YK_ENUM},
	{"error-app-tag", YK_ERROR_APP_TAG},
	{"error-message", YK_ERROR_MESSAGE},
	{"extension", YK_EXTENSION},
	{"deviation", YK_DEVIATION},
	{"deviate", YK_DEVIATE},
	{"feature", YK_FEATURE},
	{"fraction-digits", YK_FRACTION_DIGITS},
	{"grouping", YK_GROUPING},
	{"identity", YK_IDENTITY},
	{"if-feature", YK_IF_FEATURE},
	{"import", YK_IMPORT},
	{"include", YK_INCLUDE},
	{"input", YK_INPUT},
	{"key", YK_KEY},
	{"leaf", YK_LEAF},
	{"leaf-list", YK_LEAF_LIST},
	{"length", YK_LENGTH},
	{"list", YK_LIST},
	{"mandatory", YK_MANDATORY},
	{"max-elements", YK_MAX_ELEMENTS},
	{"min-elements", YK_MIN_ELEMENTS},
	{"module", YK_MODULE},
	{"must", YK_MUST},
	{"namespace", YK_NAMESPACE},
	{"notification", YK_NOTIFICATION},
	{"ordered-by", YK_ORDERED_BY},
	{"organization", YK_ORGANIZATION},
	{"output", YK_OUTPUT},
	{"path", YK_PATH},
	{"pattern", YK_PATTERN},
	{"position", YK_POSITION},
	{"prefix", YK_PREFIX},
	{"presence", YK_PRESENCE},
	{"range", YK_RANGE},
	{"reference", YK_REFERENCE},
	{"refine", YK_REFINE},
	{"require-instance", YK_REQUIRE_INSTANCE},
	{"revision", YK_REVISION},
	{"revision-date", YK_REVISION_DATE},
	{"rpc", YK_RPC},
	{"status", YK_STATUS},
	{"submodule", YK_SUBMODULE},
	{"type", YK_TYPE},
	{"typedef", YK_TYPEDEF},
	{"unique", YK_UNIQUE},
	{"units", YK_UNITS},
	{"uses", YK_USES},
	{"value", YK_VALUE},
	{"when", YK_WHEN},
	{"yang-version", YK_YANG_VERSION},
	{"yin-element", YK_YIN_ELEMENT},
	{"add", YK_ADD},
	{"current", YK_CURRENT},
	{"delete", YK_DELETE},
	{"deprecated", YK_DEPRECATED},
	{"false", YK_FALSE},
	{"max", YK_MAX},
	{"min", YK_MIN},
	{"not-supported", YK_NOT_SUPPORTED},
	{"obsolete", YK_OBSOLETE},
	{"replace", YK_REPLACE},
	{"system", YK_SYSTEM},
	{"true", YK_TRUE},
	{"unbounded", YK_UNBOUNDED},
	{"user", YK_USER},
	{"action", YK_ACTION},
	{"comment", YK_COMMENT},
	};
	
	map<string, E_YK_TYPE>::iterator it = ykmap.find(yk);

	if(it != ykmap.end())
		return it->second;	
	else
		return YK_UNKNOWN;
}
